<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Memory | Zylia's Blog]]></title>
  <link href="http://zylia.github.io/blog/categories/memory/atom.xml" rel="self"/>
  <link href="http://zylia.github.io/"/>
  <updated>2015-03-23T15:23:52+08:00</updated>
  <id>http://zylia.github.io/</id>
  <author>
    <name><![CDATA[zylia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux的虚拟内存管理(转载)]]></title>
    <link href="http://zylia.github.io/blog/2015/03/17/virtual-memory/"/>
    <updated>2015-03-17T10:32:30+08:00</updated>
    <id>http://zylia.github.io/blog/2015/03/17/virtual-memory</id>
    <content type="html"><![CDATA[<p>一个进程的虚拟地址空间主要由两个数据结来描述。一个是最高层次的：mm_struct，一个是较高层次的：vm_area_struct。
最高层次的mm_struct结构描述了一个进程的整个虚拟地址空间。较高层次的结构vm_area_struct描述了虚拟地址空间的一个区间（简称虚拟区）。
mm_struct定义在include/linux/mm_types.h中，其中的域抽象了进程的地址空间。其中：</p>

<!-- more -->


<p>[start_code,end_code)表示代码段的地址空间范围。  <br  />
[start_data,end_start)表示数据段的地址空间范围。  <br  />
[start_brk,brk)分别表示heap段的起始空间和当前的heap指针。  <br  />
[start_stack,end_stack)表示stack段的地址空间范围。  <br  />
mmap_base表示memory mapping段的起始地址。<strong>那为什么mmap段没有结束的地址呢？</strong></p>

<p>实验内容：在proc文件系统下，建立一个文件，每次向这个文件写入字符时，调用相应的虚拟内存处理函数。</p>

<pre><code>/*
mtest_dump_vma_list():print each VMA of current process, we call this function ”listvma”
mtest_find_vma():find the VMA of virtual address, we call this function “findvma”
my_follow_page():according to page table, we calculate the physical page of the virtual address, we call this function ”findpage”
mtest_write_val():write data on the specific address, we call this function “writeval”.
*/
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/vmalloc.h&gt;
MODULE_LICENSE("GPL");
/*
how to write code to look at which visual areas do the process allocate
*/

static void mtest_dump_vma_list(void)
{
  struct mm_struct * mm = current-&gt;mm;
  struct vm_area_struct *vma;
  printk("The current process is %s\n",current-&gt;comm);
  printk("mtest_dump_vma_list\n");
  down_read(&amp;mm-&gt;mmap_sem);
  for (vma = mm-&gt;mmap; vma; vma = vma-&gt;vm_next) {
    printk("VMA 0x%lx-0x%lx ", vma-&gt;vm_start, vma-&gt;vm_end);
    if (vma-&gt;vm_flags &amp; VM_WRITE)
      printk("WRITE ");
    if (vma-&gt;vm_flags &amp; VM_READ)
      printk("READ ");
    if (vma-&gt;vm_flags &amp; VM_EXEC)
      printk("EXEC ");
    printk("\n");
  }
  up_read(&amp;mm-&gt;mmap_sem);
}
/*
if we know the specific virtual address, for example, 0x8049000. How do we find which VMA does this virtual address allocate?
*/
static void mtest_find_vma(unsigned long addr)
{
  struct vm_area_struct *vma;
  struct mm_struct * mm = current-&gt;mm;
  printk("mtest_find_vma\n");
  down_read(&amp;mm-&gt;mmap_sem);
  vma = find_vma(mm, addr);
  if (vma &amp;&amp; addr &gt;= vma-&gt;vm_start) {
    printk("found vma 0x%lx-0x%lx flag %lx for addr 0x%lx\n", vma-&gt;vm_start, vma-&gt;vm_end, vma-&gt;vm_flags, addr);
  } else {
    printk("no vma found for %lx\n", addr);
  }
  up_read(&amp;mm-&gt;mmap_sem);
}
/*
A physical page is described as struct page in the kernel.
Given the virtual area VMA and the virtual address, find the physical page of this address.
*/
static struct page *my_follow_page(struct vm_area_struct *vma, unsigned long addr)
{
  pud_t *pud;
  pmd_t *pmd;
  pgd_t *pgd;
  pte_t *pte;
  spinlock_t *ptl;
  struct page *page = NULL;
  struct mm_struct *mm = vma-&gt;vm_mm;
  pgd = pgd_offset(mm, addr);
  if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd))) {
    goto out;
  }
  pud = pud_offset(pgd, addr);
  if (pud_none(*pud) || unlikely(pud_bad(*pud)))
    goto out;
  pmd = pmd_offset(pud, addr);
  if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd))) {
    goto out;
  }
  pte = pte_offset_map_lock(mm, pmd, addr, &amp;ptl);
  if (!pte)
    goto out;
  if (!pte_present(*pte))
    goto unlock;
  page = pfn_to_page(pte_pfn(*pte));
  if (!page)
    goto unlock;
  get_page(page);
unlock:
  pte_unmap_unlock(pte, ptl);
out:
  return page;
}
/*
According to the page table, calculate the physical page of the virtual address. We call this function "my_follow_page"
*/
static void mtest_find_page(unsigned long addr)
{
  struct vm_area_struct *vma;
  struct mm_struct *mm = current-&gt;mm;
  unsigned long kernel_addr;
  struct page *page;
  printk("mtest_write_val\n");
  down_read(&amp;mm-&gt;mmap_sem);
  vma = find_vma(mm, addr);
  page = my_follow_page(vma, addr);
  if (!page)
  {
    printk("page not found for 0x%lx\n", addr);
    goto out;
  }
  printk("page  found for 0x%lx\n", addr);
  kernel_addr = (unsigned long)page_address(page);
  kernel_addr += (addr&amp;~PAGE_MASK);
  printk("find 0x%lx to kernel address 0x%lx\n", addr, kernel_addr);
out:
  up_read(&amp;mm-&gt;mmap_sem);
}
/*
Whether you have the follow thought, write the data you want to the specific address?
*/
static void mtest_write_val(unsigned long addr, unsigned long val)
{
  struct vm_area_struct *vma;
  struct mm_struct *mm = current-&gt;mm;
  struct page *page;
  unsigned long kernel_addr;
  printk("mtest_write_val\n");
  down_read(&amp;mm-&gt;mmap_sem);
  vma = find_vma(mm, addr);
  if (vma &amp;&amp; addr &gt;= vma-&gt;vm_start &amp;&amp; (addr + sizeof(val)) &lt; vma-&gt;vm_end) {
    if (!(vma-&gt;vm_flags &amp; VM_WRITE)) {
      printk("vma is not writable for 0x%lx\n", addr);
      goto out;
    }
    page = my_follow_page(vma, addr);
    if (!page) {
      printk("page not found for 0x%lx\n", addr);
      goto out;
    }
    kernel_addr = (unsigned long)page_address(page);
    kernel_addr += (addr&amp;~PAGE_MASK);
    printk("write 0x%lx to address 0x%lx\n", val, kernel_addr);
    *(unsigned long *)kernel_addr = val;
    put_page(page);
  } else {
      printk("no vma found for %lx\n", addr);
  }
out:
  up_read(&amp;mm-&gt;mmap_sem);
}

static ssize_t mtest_write(struct file *file, const char __user * buffer, size_t count, loff_t *data)
{
  char buf[128];
  unsigned long val, val2;
  printk("mtest_write ........ \n");
  if (count &gt; sizeof(buf))
    return -EINVAL;
  if (copy_from_user(buf, buffer, count))
    return -EINVAL;
  if (memcmp(buf, "listvma", 7) == 0)
    mtest_dump_vma_list();
  else if (memcmp(buf, "findvma", 7) == 0) {
    if (sscanf(buf + 7, "%lx", &amp;val) == 1) {
      mtest_find_vma(val);
    }
  }
  else if (memcmp(buf, "findpage", 8) == 0) {
    if (sscanf(buf + 8, "%lx", &amp;val) == 1) {
      mtest_find_page(val);
      //my_follow_page(vma, addr);
    }
  }
  else if (memcmp(buf, "writeval", 8) == 0) {
    if (sscanf(buf + 8, "%lx %lx", &amp;val, &amp;val2) == 2) {
      mtest_write_val(val, val2);
    }
  }
  return count;
}

static struct file_operations proc_mtest_operations = {
  .write = mtest_write
};

static struct proc_dir_entry *mtest_proc_entry;
//We realize all operations in the form of mode. Therefore, the function of mode initialization and quit as shown below:
static int __init mtest_init(void)
{
  mtest_proc_entry = create_proc_entry("mtest", 0777, NULL);
  if (mtest_proc_entry == NULL) {
    printk("Error creating proc entry\n");
    return -1;
  }
  printk("create the filename mtest mtest_init sucess  \n");
  mtest_proc_entry-&gt;proc_fops = &amp;proc_mtest_operations;
  return 0;
}

static void __exit mtest_exit(void)
{
  printk("exit the module......mtest_exit \n");
  remove_proc_entry("mtest", NULL);
}
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("mtest");
MODULE_AUTHOR("Zou Nan hai");
module_init(mtest_init);
module_exit(mtest_exit);
</code></pre>

<p>转载链接: <a href="http://www.kerneltravel.net/?p=450">http://www.kerneltravel.net/?p=450</a></p>
]]></content>
  </entry>
  
</feed>
